--- /dev/null
+++ b/Documentation/devicetree/bindings/leds/leds-bcm6328.txt
@@ -0,0 +1,172 @@
+LEDs connected to Broadcom BCM6328 controller
+
+Required properties:
+- compatible : should be : "brcm,bcm6328-leds".
+- #address-cells: must be 1
+- #size-cells: must be 0
+- reg: BCM6328 LED controller address and size.
+
+Optional properties:
+- brcm,serial-leds: enable Serial LEDs.
+
+Each led is represented as a sub-node of the brcm,bcm6328-leds device.
+
+LED sub-node properties:
+- reg : LED pin number (could be from 0 to 23).
+- compatible : should be : "brcm,bcm6328-led".
+
+Normal LED:
+- label (optional) : see Documentation/devicetree/bindings/leds/common.txt
+- active-low (optional) : LED is active low.
+- default-state (optional): see
+  Documentation/devicetree/bindings/leds/leds-gpio.txt
+- linux,default-trigger (optional): see
+  Documentation/devicetree/bindings/leds/common.txt
+
+Hardware controlled LED:
+- brcm,hardware-controlled (optional) : LED is hardware controlled.
+- brcm,link-selection (optional) : LED link selection values.
+- brcm,activity-selection (optional) : LED activity selection values.
+
+example 1) BCM6328
+
+leds0: led-controller@10000800 {
+	compatible = "brcm,bcm6328-leds";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	reg = <0x10000800 0x24>;
+
+	alarm_red@2 {
+		compatible = "brcm,bcm6328-led";
+		reg = <2>;
+		active-low;
+		label = "red:alarm";
+	};
+	inet_green@3 {
+		compatible = "brcm,bcm6328-led";
+		reg = <3>;
+		active-low;
+		label = "green:inet";
+	};
+	power_green@4 {
+		compatible = "brcm,bcm6328-led";
+		reg = <4>;
+		active-low;
+		label = "green:power";
+		default-state = "on";
+	};
+	ephy0_spd@17 {
+		compatible = "brcm,bcm6328-led";
+		reg = <17>;
+		brcm,hardware-controlled;
+	};
+	ephy1_spd@18 {
+		compatible = "brcm,bcm6328-led";
+		reg = <18>;
+		brcm,hardware-controlled;
+	};
+	ephy2_spd@19 {
+		compatible = "brcm,bcm6328-led";
+		reg = <19>;
+		brcm,hardware-controlled;
+	};
+	ephy3_spd@20 {
+		compatible = "brcm,bcm6328-led";
+		reg = <20>;
+		brcm,hardware-controlled;
+	};
+};
+
+example 2) BCM63268
+
+leds0: led-controller@10001900 {
+	compatible = "brcm,bcm6328-leds";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	reg = <0x10001900 0x24>;
+
+	gphy0_spd0@0 {
+		compatible = "brcm,bcm6328-led";
+		reg = <0>;
+		brcm,hardware-controlled;
+		brcm,link-selection = <0>;
+	};
+	gphy0_spd1@1 {
+		compatible = "brcm,bcm6328-led";
+		reg = <1>;
+		brcm,hardware-controlled;
+		brcm,link-selection = <1>;
+	};
+	inet_red@2 {
+		compatible = "brcm,bcm6328-led";
+		reg = <2>;
+		active-low;
+		label = "red:inet";
+	};
+	dsl_green@3 {
+		compatible = "brcm,bcm6328-led";
+		reg = <3>;
+		active-low;
+		label = "green:dsl";
+	};
+	usb_green@4 {
+		compatible = "brcm,bcm6328-led";
+		reg = <4>;
+		active-low;
+		label = "green:usb";
+	};
+	wps_green@7 {
+		compatible = "brcm,bcm6328-led";
+		reg = <7>;
+		active-low;
+		label = "green:wps";
+	};
+	inet_green@8 {
+		compatible = "brcm,bcm6328-led";
+		reg = <8>;
+		active-low;
+		label = "green:inet";
+	};
+	ephy0_act@9 {
+		compatible = "brcm,bcm6328-led";
+		reg = <9>;
+		brcm,hardware-controlled;
+	};
+	ephy1_act@10 {
+		compatible = "brcm,bcm6328-led";
+		reg = <10>;
+		brcm,hardware-controlled;
+	};
+	ephy2_act@11 {
+		compatible = "brcm,bcm6328-led";
+		reg = <11>;
+		brcm,hardware-controlled;
+	};
+	gphy0_act@12 {
+		compatible = "brcm,bcm6328-led";
+		reg = <12>;
+		brcm,hardware-controlled;
+	};
+	ephy0_spd@13 {
+		compatible = "brcm,bcm6328-led";
+		reg = <13>;
+		brcm,hardware-controlled;
+	};
+	ephy1_spd@14 {
+		compatible = "brcm,bcm6328-led";
+		reg = <14>;
+		brcm,hardware-controlled;
+	};
+	ephy2_spd@15 {
+		compatible = "brcm,bcm6328-led";
+		reg = <15>;
+		brcm,hardware-controlled;
+	};
+	power_green@20 {
+		compatible = "brcm,bcm6328-led";
+		reg = <20>;
+		active-low;
+		label = "green:power";
+		default-state = "on";
+	};
+};
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -32,6 +32,14 @@ config LEDS_88PM860X
 	  This option enables support for on-chip LED drivers found on Marvell
 	  Semiconductor 88PM8606 PMIC.
 
+config LEDS_BCM6328
+	tristate "Serial LEDs support for BCM6328 chip"
+	depends on LEDS_CLASS
+	depends on OF
+	help
+	  This option enables support for LEDs connected to the BCM6328
+	  LED HW controller accessed via MMIO registers.
+
 config LEDS_LM3530
 	tristate "LCD Backlight driver for LM3530"
 	depends on LEDS_CLASS
--- /dev/null
+++ b/drivers/leds/leds-bcm6328.c
@@ -0,0 +1,407 @@
+/*
+ * Driver for BCM6328 memory-mapped LEDs, based on leds-syscon.c
+ *
+ * Copyright 2015 Álvaro Fernández Rojas <noltari@gmail.com>
+ * Copyright 2015 Jonas Gorski <jogo@openwrt.org>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/io.h>
+#include <linux/leds.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+
+#define REG_INIT		0x00
+#define REG_MODE_HI		0x04
+#define REG_MODE_LO		0x08
+#define REG_HWDIS		0x0c
+#define REG_STROBE		0x10
+#define REG_LNKACTSEL_HI	0x14
+#define REG_LNKACTSEL_LO	0x18
+#define REG_RBACK		0x1c
+#define REG_SERMUX		0x20
+
+#define LED_MAX_COUNT		24
+#define LED_DEF_DELAY		500
+#define LED_INTERVAL_MS		20
+
+#define LED_INTV_MASK		0x3f
+#define LED_FAST_INTV_SHIFT	6
+#define LED_FAST_INTV_MASK	(LED_INTV_MASK << LED_FAST_INTV_SHIFT)
+#define SERIAL_LED_EN		BIT(12)
+#define SERIAL_LED_MUX		BIT(13)
+#define SERIAL_LED_CLK_NPOL	BIT(14)
+#define SERIAL_LED_DATA_PPOL	BIT(15)
+#define SERIAL_LED_SHIFT_DIR	BIT(16)
+#define LED_SHIFT_TEST		BIT(30)
+#define LED_TEST		BIT(31)
+
+#define LED_MODE_MASK		3
+#define LED_MODE_OFF		0
+#define LED_MODE_FAST		1
+#define LED_MODE_BLINK		2
+#define LED_MODE_ON		3
+#define LED_SHIFT(X)		((X) << 1)
+
+/**
+ * struct bcm6328_led - state container for bcm6328 based LEDs
+ * @cdev: LED class device for this LED
+ * @mem: memory resource
+ * @lock: memory lock
+ * @pin: LED pin number
+ * @blink_leds: blinking LEDs
+ * @blink_del: blinking delay
+ * @active_low: LED is active low
+ */
+struct bcm6328_led {
+	struct led_classdev cdev;
+	void __iomem *mem;
+	spinlock_t *lock;
+	unsigned long pin;
+	unsigned long *blink_leds;
+	unsigned long *blink_del;
+	bool active_low;
+};
+
+static void bcm6328_led_write(void __iomem *reg, unsigned long data)
+{
+	iowrite32be(data, reg);
+}
+
+static unsigned long bcm6328_led_read(void __iomem *reg)
+{
+	return ioread32be(reg);
+}
+
+/**
+ * LEDMode 64 bits / 24 LEDs
+ * bits [31:0] -> LEDs 8-23
+ * bits [47:32] -> LEDs 0-7
+ * bits [63:48] -> unused
+ */
+static unsigned long bcm6328_pin2shift(unsigned long pin)
+{
+	if (pin < 8)
+		return pin + 16; /* LEDs 0-7 (bits 47:32) */
+	else
+		return pin - 8; /* LEDs 8-23 (bits 31:0) */
+}
+
+static void bcm6328_led_mode(struct bcm6328_led *led, unsigned long value)
+{
+	void __iomem *mode;
+	unsigned long val, shift;
+
+	shift = bcm6328_pin2shift(led->pin);
+	if (shift / 16)
+		mode = led->mem + REG_MODE_HI;
+	else
+		mode = led->mem + REG_MODE_LO;
+
+	val = bcm6328_led_read(mode);
+	val &= ~(LED_MODE_MASK << LED_SHIFT(shift % 16));
+	val |= (value << LED_SHIFT(shift % 16));
+	bcm6328_led_write(mode, val);
+}
+
+static void bcm6328_led_set(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	struct bcm6328_led *led =
+		container_of(led_cdev, struct bcm6328_led, cdev);
+	unsigned long flags;
+
+	spin_lock_irqsave(led->lock, flags);
+	*(led->blink_leds) &= ~BIT(led->pin);
+	if ((led->active_low && value == LED_OFF) ||
+	    (!led->active_low && value != LED_OFF))
+		bcm6328_led_mode(led, LED_MODE_OFF);
+	else
+		bcm6328_led_mode(led, LED_MODE_ON);
+	spin_unlock_irqrestore(led->lock, flags);
+}
+
+static int bcm6328_blink_set(struct led_classdev *led_cdev,
+			     unsigned long *delay_on, unsigned long *delay_off)
+{
+	struct bcm6328_led *led =
+		container_of(led_cdev, struct bcm6328_led, cdev);
+	unsigned long delay, flags;
+
+	if (!*delay_on)
+		*delay_on = LED_DEF_DELAY;
+	if (!*delay_off)
+		*delay_off = LED_DEF_DELAY;
+
+	if (*delay_on != *delay_off) {
+		dev_dbg(led_cdev->dev,
+			"fallback to soft blinking (delay_on != delay_off)\n");
+		return -EINVAL;
+	}
+
+	delay = *delay_on / LED_INTERVAL_MS;
+	if (delay == 0)
+		delay = 1;
+	else if (delay > LED_INTV_MASK) {
+		dev_dbg(led_cdev->dev,
+			"fallback to soft blinking (delay > %ums)\n",
+			LED_INTV_MASK * LED_INTERVAL_MS);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(led->lock, flags);
+	if (*(led->blink_leds) == 0 ||
+	    *(led->blink_leds) == BIT(led->pin) ||
+	    *(led->blink_del) == delay) {
+		unsigned long val;
+
+		*(led->blink_leds) = BIT(led->pin);
+		*(led->blink_del) = delay;
+
+		val = bcm6328_led_read(led->mem + REG_INIT);
+		val &= ~LED_FAST_INTV_MASK;
+		val |= (delay << LED_FAST_INTV_SHIFT);
+		bcm6328_led_write(led->mem + REG_INIT, val);
+
+		bcm6328_led_mode(led, LED_MODE_BLINK);
+
+		spin_unlock_irqrestore(led->lock, flags);
+	} else {
+		spin_unlock_irqrestore(led->lock, flags);
+		dev_dbg(led_cdev->dev,
+			"fallback to soft blinking (delay already set)\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int bcm6328_hwled(struct device *dev, struct device_node *nc, u32 reg,
+			 void __iomem *mem, spinlock_t *lock)
+{
+	int i, cnt;
+	unsigned long flags, val;
+
+	spin_lock_irqsave(lock, flags);
+	val = bcm6328_led_read(mem + REG_HWDIS);
+	val &= ~BIT(reg);
+	bcm6328_led_write(mem + REG_HWDIS, val);
+	spin_unlock_irqrestore(lock, flags);
+
+	/* Only LEDs 0-7 can be activity/link controlled */
+	if (reg >= 8)
+		return 0;
+
+	cnt = of_property_count_elems_of_size(nc, "brcm,link-selection",
+					      sizeof(u32));
+	for (i = 0; i < cnt; i++) {
+		u32 sel;
+		void __iomem *addr;
+
+		if (reg < 4)
+			addr = mem + REG_LNKACTSEL_LO;
+		else
+			addr = mem + REG_LNKACTSEL_HI;
+
+		of_property_read_u32_index(nc, "brcm,link-selection", i, &sel);
+
+		if (reg / 4 != sel / 4) {
+			dev_warn(dev, "invalid link selection\n");
+			continue;
+		}
+
+		spin_lock_irqsave(lock, flags);
+		val = bcm6328_led_read(addr);
+		val |= (BIT(reg) << (((sel % 4) * 4) + 16));
+		bcm6328_led_write(addr, val);
+		spin_unlock_irqrestore(lock, flags);
+	}
+
+	cnt = of_property_count_elems_of_size(nc, "brcm,activity-selection",
+					      sizeof(u32));
+	for (i = 0; i < cnt; i++) {
+		u32 sel;
+		void __iomem *addr;
+
+		if (reg < 4)
+			addr = mem + REG_LNKACTSEL_LO;
+		else
+			addr = mem + REG_LNKACTSEL_HI;
+
+		of_property_read_u32_index(nc, "brcm,activity-selection", i,
+					   &sel);
+
+		if (reg / 4 != sel / 4) {
+			dev_warn(dev, "invalid activity selection\n");
+			continue;
+		}
+
+		spin_lock_irqsave(lock, flags);
+		val = bcm6328_led_read(addr);
+		val |= (BIT(reg) << ((sel % 4) * 4));
+		bcm6328_led_write(addr, val);
+		spin_unlock_irqrestore(lock, flags);
+	}
+
+	return 0;
+}
+
+static int bcm6328_led(struct device *dev, struct device_node *nc, u32 reg,
+		       void __iomem *mem, spinlock_t *lock,
+		       unsigned long *blink_leds, unsigned long *blink_del)
+{
+	struct bcm6328_led *led;
+	unsigned long flags;
+	const char *state;
+	int ret;
+
+	led = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);
+	if (!led)
+		return -ENOMEM;
+
+	led->pin = reg;
+	led->mem = mem;
+	led->lock = lock;
+	led->blink_leds = blink_leds;
+	led->blink_del = blink_del;
+
+	if (of_get_property(nc, "active-low", NULL))
+		led->active_low = 1;
+
+	led->cdev.name = of_get_property(nc, "label", NULL) ? : nc->name;
+	led->cdev.default_trigger = of_get_property(nc,
+						    "linux,default-trigger",
+						    NULL);
+
+	if (!of_property_read_string(nc, "default-state", &state)) {
+		spin_lock_irqsave(lock, flags);
+		if (!strcmp(state, "on")) {
+			led->cdev.brightness = LED_FULL;
+			bcm6328_led_mode(led, LED_MODE_ON);
+		} else if (!strcmp(state, "keep")) {
+			void __iomem *mode;
+			unsigned long val, shift;
+
+			shift = bcm6328_pin2shift(led->pin);
+			if (shift / 16)
+				mode = mem + REG_MODE_HI;
+			else
+				mode = mem + REG_MODE_LO;
+
+			val = bcm6328_led_read(mode) >> (shift % 16);
+			val &= LED_MODE_MASK;
+			if (val == LED_MODE_ON)
+				led->cdev.brightness = LED_FULL;
+			else {
+				led->cdev.brightness = LED_OFF;
+				bcm6328_led_mode(led, LED_MODE_OFF);
+			}
+		} else {
+			led->cdev.brightness = LED_OFF;
+			bcm6328_led_mode(led, LED_MODE_OFF);
+		}
+		spin_unlock_irqrestore(lock, flags);
+	}
+
+	led->cdev.brightness_set = bcm6328_led_set;
+	led->cdev.blink_set = bcm6328_blink_set;
+
+	ret = led_classdev_register(dev, &led->cdev);
+	if (ret < 0)
+		return ret;
+
+	dev_info(dev, "registered LED %s\n", led->cdev.name);
+
+	return 0;
+}
+
+static int bcm6328_leds_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *child;
+	struct resource *mem_r;
+	void __iomem *mem;
+	spinlock_t *lock;
+	unsigned long val, *blink_leds, *blink_del;
+
+	mem_r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_r)
+		return -EINVAL;
+
+	mem = devm_ioremap_resource(dev, mem_r);
+	if (IS_ERR(mem))
+		return PTR_ERR(mem);
+
+	lock = devm_kzalloc(dev, sizeof(*lock), GFP_KERNEL);
+	if (!lock)
+		return -ENOMEM;
+
+	blink_leds = devm_kzalloc(dev, sizeof(*blink_leds), GFP_KERNEL);
+	if (!blink_leds)
+		return -ENOMEM;
+
+	blink_del = devm_kzalloc(dev, sizeof(*blink_del), GFP_KERNEL);
+	if (!blink_del)
+		return -ENOMEM;
+
+	spin_lock_init(lock);
+
+	bcm6328_led_write(mem + REG_HWDIS, ~0);
+	bcm6328_led_write(mem + REG_LNKACTSEL_HI, 0);
+	bcm6328_led_write(mem + REG_LNKACTSEL_LO, 0);
+
+	val = bcm6328_led_read(mem + REG_INIT);
+	val &= ~SERIAL_LED_EN;
+	if (of_get_property(np, "brcm,serial-leds", NULL))
+		val |= SERIAL_LED_EN;
+	bcm6328_led_write(mem + REG_INIT, val);
+
+	for_each_available_child_of_node(np, child) {
+		int ret;
+		u32 reg;
+
+		if (!of_device_is_compatible(child, "brcm,bcm6328-led") ||
+		    of_property_read_u32(child, "reg", &reg))
+			continue;
+
+		if (reg >= LED_MAX_COUNT) {
+			dev_err(dev, "invalid LED (>= %d)\n", LED_MAX_COUNT);
+			continue;
+		}
+
+		if (of_get_property(child, "brcm,hardware-controlled", NULL))
+			ret = bcm6328_hwled(dev, child, reg, mem, lock);
+		else
+			ret = bcm6328_led(dev, child, reg, mem, lock,
+					  blink_leds, blink_del);
+
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id bcm6328_leds_of_match[] = {
+	{ .compatible = "brcm,bcm6328-leds", },
+	{},
+};
+
+static struct platform_driver bcm6328_leds_driver = {
+	.probe = bcm6328_leds_probe,
+	.driver = {
+		.name = "bcm6328-leds",
+		.of_match_table = bcm6328_leds_of_match,
+	},
+};
+
+module_platform_driver(bcm6328_leds_driver);
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_LEDS_TRIGGERS)		+= led-trig
 
 # LED Platform Drivers
 obj-$(CONFIG_LEDS_88PM860X)		+= leds-88pm860x.o
+obj-$(CONFIG_LEDS_BCM6328)		+= leds-bcm6328.o
 obj-$(CONFIG_LEDS_BD2802)		+= leds-bd2802.o
 obj-$(CONFIG_LEDS_LOCOMO)		+= leds-locomo.o
 obj-$(CONFIG_LEDS_LM3530)		+= leds-lm3530.o
